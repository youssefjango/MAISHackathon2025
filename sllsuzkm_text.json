{
    "text": "This document provides an organized summary of concepts related to C Structures (structs), based on COMP206 course materials from McGill University.\n\n---\n\n**COMP206 – Software Systems: Lesson 16 - Struct**\n*   **Topic:** Struct and Union Notes (Focus on Structs)\n*   **Textbook Reference:** Section 3.0, Example 7\n*   **Source:** McGill Slides – Vybihal & Bérubé-Vallières © 2023\n*   **Environment:** Unix, Bash, C, GNU Systems\n\n---\n\n## 1. Introduction to Structures (`struct`)\n\n*   **Definition:** Structures are a collection of items that may have different data types.\n*   **Members:** The elements within a structure are called members.\n*   **Access:** Unlike arrays, structure members are accessed by their name.\n\n## 2. Declaring and Accessing Structures\n\n### 2.1 Anonymous Structures (without a Tag)\n\nInitially, structures can be declared without a specific tag. This is useful for simple, one-off declarations but can become cumbersome if the same structure definition is needed multiple times.\n\n*   **Declaration as a Global Variable (Example 1):**\n    A structure can be declared globally, and its members accessed using the dot operator (`.`).\n\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n\n    // Global, anonymous structure variable 'a'\n    struct {\n        char name[30]; // member\n        int age;       // member\n        float salary;  // member\n    } a; // notice the semi-colon after the closing brace\n\n    int main(void) {\n        // Accessing members\n        a.age = 25;\n        strcpy(a.name, \"John\");\n        printf(\"%s is %d years old\\n\", a.name, a.age); // Output: John is 25 years old\n    }\n    ```\n    *   **Note:** In `struct { ... } a;`, `struct { ... }` represents the *type*, and `a` is the *variable name*.\n\n*   **Declaring Multiple Variables (Example 2):**\n    Multiple variables of the same anonymous structure type can be declared at once, similar to declaring multiple variables of a primitive type.\n\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n\n    struct {\n        char name[30];\n        int age;\n        float salary;\n    } a, b; // Declares two global variables 'a' and 'b'\n\n    int main(void) {\n        a.age = 25;\n        strcpy(a.name, \"John\");\n        b.age = 30;\n        strcpy(b.name, \"Bob\");\n        printf(\"%s is %d years old, %s is %d years old\\n\", a.name, a.age, b.name, b.age);\n        // Output: John is 25 years old, Bob is 30 years old\n    }\n    ```\n\n*   **Limitations of Local Anonymous Structures (Example 3):**\n    Declaring the same anonymous structure locally in different places requires repeating the full structure definition, which is cumbersome and inefficient. This highlights the need for structure tags.\n\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n\n    int main(void) {\n        struct { char name[30]; int age; float salary; } a;\n        // ... code ...\n        struct { char name[30]; int age; float salary; } b; // Repetition of definition\n    }\n    ```\n\n### 2.2 Structures with Tags\n\nStructure tags provide a way to name a structure definition, allowing it to be reused without re-typing the entire definition. This is the more common and recommended approach.\n\n*   **Declaring a Structure Tag (Example 4):**\n    A `tag` is a name given to the structure definition. This allows you to declare variables of that structure type later using `struct TagName variable;`.\n\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n\n    // Defines a structure type named 'PERSON'\n    struct PERSON { // 'PERSON' is the tag\n        char name[30];\n        int age;\n        float salary;\n    }; // Notice the semi-colon even though no variable declaration here\n\n    int main(void) {\n        struct PERSON a; // Declares a local variable 'a' of type 'struct PERSON'\n        // ... code ...\n        struct PERSON b; // Declares another local variable 'b'\n    }\n    ```\n    *   The `tag` replaces the need to repeat the member definitions.\n\n*   **Combining Tag Definition with Variable Declaration (Example 5):**\n    You can still declare variables (global or local, single or multiple) at the same time you define the structure tag.\n\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n\n    struct PERSON { // 'PERSON' is the tag\n        char name[30];\n        int age;\n        float salary;\n    } d; // Declares a global variable 'd' of type 'struct PERSON'\n\n    int main(void) {\n        struct PERSON a, b; // Declares two local variables 'a' and 'b'\n        // ... code ...\n        struct PERSON c;    // Declares another local variable 'c'\n    }\n    ```\n\n### 2.3 General Syntax of `struct`\n\nThe general syntax for defining a structure type is:\n\n```c\nstruct OPTIONAL_TAG {\n    MEMBERS;\n};\n```\n\n*   **`OPTIONAL_TAG`**: A user-defined tag (name) for the structure. If it's not present, the struct is anonymous.\n*   **`MEMBERS`**: A list of semicolon-separated variable declarations, defining the fields of the structure.\n    *   Example: `TYPE1 VAR1; TYPE2 VAR2; etc.`\n*   **Important Note:** You cannot initialize members from inside the struct definition (e.g., `int age = 0;` is not allowed here). Initialization happens when a variable of the struct type is declared or later at runtime.\n\n## 3. Operations with Structures\n\n### 3.1 The Dot Operator (`.`)\n\nThe dot operator is used to access individual members (fields) within a structure variable.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct PERSON {\n    char name[30];\n    int age;\n    float salary;\n};\n\nint main(void) {\n    struct PERSON a; // Declare a structure variable 'a'\n\n    // Use the dot operator to access and assign values to members\n    printf(\"Enter name: \");\n    scanf(\"%s\", a.name);      // For arrays (like char name[]), no '&' needed\n    printf(\"Enter age: \");\n    scanf(\"%d\", &(a.age));    // For non-array types, '&' is needed for scanf\n    a.salary = 50.25;         // Direct assignment\n\n    printf(\"%s %d %f\\n\", a.name, a.age, a.salary);\n}\n```\n\n### 3.2 Structure Assignment\n\n*   **Feature:** Unlike arrays, you can use the assignment operator (`=`) directly with structures.\n*   **Compatibility:** This is possible if the structures have compatible types (e.g., declared with the same tag, or if anonymous, declared at the same time).\n*   **Mechanism:** The assignment copies every member's value one by one from the right-hand side structure to the left-hand side structure.\n\n    ```c\n    #include <stdio.h>\n\n    struct COORDINATE {\n        int x;\n        int y;\n    };\n\n    int main(void) {\n        struct COORDINATE a, b;\n        a.x = 5;\n        a.y = 7;\n\n        b = a; // Assignment operator copies all members: b.x = a.x; b.y = a.y;\n\n        printf(\"The coordinate of b is (%d, %d)\\n\", b.x, b.y); // Output: (5, 7)\n    }\n    ```\n*   **Array Members:** This assignment also works even if the structure contains array members. For example, if `struct { int arr[5]; } s1, s2;` then `s2 = s1;` would copy the entire `arr` array.\n\n### 3.3 Nested Structures\n\nStructures can be used as members within other structures. This allows for complex, hierarchical data organization.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct NAME {\n    char first[30];\n    char last[30];\n};\n\nstruct PERSON {\n    struct NAME name; // 'name' is a member of type 'struct NAME'\n    int age;\n    float salary;\n};\n\n// Function that accepts a struct as an argument\nvoid print_name(struct NAME n) {\n    printf(\"%s %s\\n\", n.first, n.last);\n}\n\nint main(void) {\n    struct PERSON a;\n\n    // Accessing nested members uses chained dot operators\n    strcpy(a.name.first, \"John\");\n    strcpy(a.name.last, \"Smith\");\n\n    // Other members\n    a.age = 30;\n    a.salary = 60000.0f;\n\n    print_name(a.name); // Pass the nested struct 'a.name' to the function\n    // Output: John Smith\n}\n```\n\n### 3.4 `typedef` with Structures\n\nThe `typedef` keyword is often used in combination with structures to create a new alias (shorter, cleaner name) for a structure type, avoiding the need to use the `struct` keyword every time.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Define a new type 'Person' as an alias for 'struct { ... }'\ntypedef struct {\n    char name[30];\n    int age;\n    float salary;\n} Person; // 'Person' is the new type name, not a variable declaration\n\nint main(void) {\n    Person a, b; // Declare variables using the new type alias 'Person'\n    // ... code ...\n    Person c;    // No 'struct' keyword needed\n    \n    strcpy(a.name, \"Alice\");\n    a.age = 28;\n    a.salary = 75000.0f;\n    \n    printf(\"%s is %d years old\\n\", a.name, a.age); // Output: Alice is 28 years old\n}\n```\n*   Remember that `typedef` is used like: `typedef existing_type new_name;`\n\n### 3.5 Array of Structures\n\nYou can declare arrays where each element is a structure. This allows storing collections of structured data.\n\n```c\n#include <stdio.h>\n\nstruct PERSON {\n    char name[30];\n    int age;\n    float salary;\n}; // Structure definition\n\nint main() {\n    struct PERSON people[100]; // Declare an array of 100 PERSON structures\n\n    for (int x = 0; x < 100; x++) {\n        printf(\"Enter name for person %d: \", x + 1);\n        scanf(\"%s\", people[x].name);\n        printf(\"Enter age: \");\n        scanf(\"%d\", &(people[x].age));\n        printf(\"Enter salary: \");\n        scanf(\"%f\", &(people[x].salary));\n\n        if (people[x].age == 20) {\n            printf(\"Hey you are 20!!\\n\");\n        }\n    }\n    // ... further processing of the 'people' array ...\n}\n```\n\n### 3.6 `sizeof` and Structures (Memory Alignment)\n\n*   **Memory Layout:** In memory, members of a structure are generally placed in sequence.\n*   **Padding:** However, computers often require addresses of certain data types to be on specific multiples (e.g., integers on multiples of 4 bytes). To achieve this \"memory alignment,\" the compiler might insert \"unused bytes\" (padding) between structure elements.\n*   **`sizeof` Result:** Because of padding, the value returned by `sizeof(struct_name)` might be larger than the simple sum of the sizes of its individual members.\n\n    ```\n    struct PERSON {\n        char name[30]; // e.g., 30 bytes\n        int age;       // e.g., 4 bytes\n        float salary;  // e.g., 4 bytes\n    };\n\n    // Conceptual memory layout (actual padding depends on compiler/architecture)\n    // PERSON:\n    // [char name[30]]\n    // [padding if needed]\n    // [int age]\n    // [padding if needed]\n    // [float salary]\n    // [padding at end if needed for array of structs]\n    ```\n\n## 4. Recap and Key Takeaways\n\n*   **Structure Syntax:**\n    *   `struct OPTIONAL_TAG { MEMBERS; } OPTIONAL_VARIABLES;`\n    *   `typedef struct { MEMBERS; } NEW_TYPE_NAME;`\n*   **Function Arguments and Returns:** You can pass structs by value or by reference (using pointers) as arguments to functions, and functions can also return structs.\n*   **Convenience:** Structures make it much more convenient to group and move related data (including arrays) as a single, cohesive unit.\n*   **Size:** The size of a struct (`sizeof`) is not necessarily the sum of the sizes of its fields, as padding bytes may be added by the compiler for memory alignment efficiency.\n\n---\n\n## 5. Practice Problem\n\nWrite a C program that does the following:\n\n1.  **Define a struct `Coord` type** representing a coordinate in a 2D space (X and Y integers).\n2.  **Implement a function `read_coords(int *capacity)`** that:\n    *   Allocates a dynamic array named `CoordArray` of `struct Coord` type.\n    *   The capacity of this array should be chosen by the user.\n    *   Reads coordinate inputs (X and Y) from the user and stores them in the dynamically allocated `CoordArray`.\n    *   Returns the dynamically allocated array.\n3.  **Implement a function `Coord centroid(Coord *arr, int capacity)`** that:\n    *   Computes the centroid (average X and average Y) of all coordinates stored in the `arr`.\n    *   Returns this centroid as a `Coord` structure.\n4.  **In the `main` function:**\n    *   Call `read_coords` to get the array of coordinates.\n    *   Call `centroid` to compute the centroid.\n    *   Output the computed centroid to the user.\n    *   Remember to free dynamically allocated memory.",
    "restriction": "The size of each page should be of the format of one A4(8.27 × 11.69 in). There should be 3 pages exactly allowed. The content should be prioritized in the cheatsheet should be key concepts, examples. The following features of the crib sheet should make the sheet more comfortable to use, and should be prioritized: Lots of white space and clear sections, Compact, dense information in small text. The overall layout style should be Free-form notes and sketches. The font size used in the cheatsheet should be in the Medium (11-12 pt) range to ensure readability and efficiency.",
    "error": null
}