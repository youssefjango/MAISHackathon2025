{
    "text": "Here's the text reformatted for clarity and organization, preserving all critical information:\n\n---\n\n# C Structures (Struct) - COMP 206 Lesson 16\n\n**Course:** Unix Bash C GNU Systems COMP 206 – Software Systems\n**Lesson:** Struct – Software Systems\n**References:**\n*   Textbook: Section 3.0, Example 7\n*   Source: McGill Slides – Vybihal & Bérubé-Vallières © 2023\n\n---\n\n## 1. Introduction to Structures\n\n*   **Definition:** Structures (`struct`) are a collection of items that may have different types.\n*   **Members:** Its elements are called members.\n*   **Access:** Unlike arrays, members are accessed by name.\n\n## 2. Declaring Structures\n\n### 2.1 Anonymous Structures (Examples 1 & 2)\n\nAn anonymous structure is declared without a tag. Variables of this type must be declared directly after the structure definition.\n\n*   **Declaration as a Global Variable:**\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n\n    struct { // This defines an anonymous struct type\n        char name[30];\n        int age;\n        float salary;\n    } a; // 'a' is a global variable of this anonymous struct type\n\n    int main(void) {\n        a.age = 25; // Accessing members using the dot operator\n        strcpy(a.name, \"John\");\n        printf(\"%s is %d years old\\n\", a.name, a.age);\n    }\n    ```\n    *   **Note:** The declaration follows the usual form: `type` (the anonymous `struct {...}`) followed by the `variable name` (`a`).\n    *   **In Reality:** You would most likely use a structure tag, as seen later in this lesson.\n\n*   **Declaring Multiple Variables:**\n    Multiple variables of the same anonymous struct type can be declared at once, similar to declaring multiple variables of a primitive type.\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n\n    struct {\n        char name[30];\n        int age;\n        float salary;\n    } a, b; // 'a' and 'b' are global variables of this anonymous struct type\n\n    int main(void) {\n        a.age = 25;\n        strcpy(a.name, \"John\");\n        b.age = 30;\n        strcpy(b.name, \"Bob\");\n        printf(\"%s is %d years old, %s is %d years old\\n\", a.name, a.age, b.name, b.age);\n    }\n    ```\n    *   **Note:** Declarations can be of the form \"`type var_name1, var_name2, ...`\".\n\n### 2.2 Problem with Anonymous Local Structures (Example 3)\n\nDeclaring the same anonymous structure locally at different places leads to cumbersome and repetitive code, as each instance effectively defines a new, distinct type.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    struct { // First local anonymous struct\n        char name[30];\n        int age;\n        float salary;\n    } a;\n    /* ... */\n    struct { // Second local anonymous struct (duplicate definition)\n        char name[30];\n        int age;\n        float salary;\n    } b;\n}\n```\n*   **Issue:** Each `struct { ... }` block creates a *new*, unique anonymous type. Variables `a` and `b` in this example are of incompatible types despite having identical member definitions.\n*   **Solution:** A better way is to use structure tags.\n\n### 2.3 Structures with Tags (Examples 4 & 5)\n\nUsing a tag allows you to define a structure type once and then declare variables of that type anywhere, avoiding repetition and ensuring type compatibility.\n\n*   **Defining a Tagged Structure:**\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n\n    struct PERSON { // 'PERSON' is the tag, defining a new struct type\n        char name[30];\n        int age;\n        float salary;\n    }; // Notice the semi-colon even though no variable declaration\n\n    int main(void) {\n        struct PERSON a; // Declaring a variable of type 'struct PERSON'\n        /* ... */\n        struct PERSON b; // Declaring another variable of the same type\n    }\n    ```\n    *   **Benefit:** The tag `PERSON` replaces the need to redefine the members repeatedly.\n\n*   **Combining Tags with Variable Declarations:**\n    You can still declare variables (global or local, single or multiple) simultaneously with the tagged structure definition.\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n\n    struct PERSON { // Tag 'PERSON'\n        char name[30];\n        int age;\n        float salary;\n    } d; // 'd' is a global variable of type 'struct PERSON'\n\n    int main(void) {\n        struct PERSON a, b; // 'a' and 'b' are local variables of type 'struct PERSON'\n        /* ... */\n        struct PERSON c;\n    }\n    ```\n\n### 2.4 General Syntax of `struct` (Slide 9)\n\nThe general syntax for defining a structure type is:\n```c\nstruct OPTIONAL_TAG {\n    MEMBERS;\n};\n```\nWhere:\n*   `OPTIONAL_TAG`: A user-defined tag (e.g., `PERSON`). If not present, the struct is anonymous.\n*   `MEMBERS`: A list of semi-colon separated variable declarations defining the struct's elements.\n    ```c\n    TYPE1 VAR1;\n    TYPE2 VAR2;\n    // etc.\n    ```\n*   **Important Note:** You cannot initialize members from inside the struct definition (e.g., you cannot write `int age = 0;`).\n\n## 3. Accessing Structure Members: The Dot Operator\n\nThe dot operator (`.`) is used to access individual fields (members) within a structure variable.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct PERSON {\n    char name[30];\n    int age;\n    float salary;\n};\n\nint main(void) {\n    struct PERSON a;\n\n    // Reading input into struct members\n    printf(\"Enter name: \");\n    scanf(\"%s\", a.name);       // For char arrays, 'a.name' is already an address\n    printf(\"Enter age: \");\n    scanf(\"%d\", &(a.age));     // For scalar types, use '&' for scanf\n    \n    // Assigning a value\n    a.salary = 50.25;\n\n    // Printing struct members\n    printf(\"%s %d %f\\n\", a.name, a.age, a.salary);\n    \n    return 0;\n}\n```\n\n## 4. Structure Assignment (Examples 13 & 14)\n\nUnlike arrays, you can use the assignment operator (`=`) with entire structs, provided they have compatible types (declared with the same tag, or if anonymous, declared at the same time).\n\n*   **Mechanism:** The assignment copies every member's value one by one (e.g., `b.x = a.x; b.y = a.y;`).\n*   **Compatibility:** This works even if structs contain arrays as members; the array contents will be copied.\n\n```c\n#include <stdio.h>\n\nstruct COORDINATE {\n    int x;\n    int y;\n};\n\nint main(void) {\n    struct COORDINATE a, b;\n    a.x = 5;\n    a.y = 7;\n    \n    b = a; // Struct assignment: copies all members from 'a' to 'b'\n\n    printf(\"The coordinate of b is (%d, %d)\\n\", b.x, b.y);\n\n    // Example with arrays inside structs\n    struct { int arr[5]; } c, d; // Anonymous structs, declared at same time\n    c.arr[0] = 5;\n    d = c; // Copies the entire array\n    printf(\"d.arr[0] is %d\\n\", d.arr[0]); // Outputs 5\n    \n    return 0;\n}\n```\n\n## 5. Nested Structures (Example 15)\n\nStructures can be used as members within other structures, allowing for more complex data organization.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct NAME {\n    char first[30];\n    char last [30];\n};\n\nstruct PERSON {\n    struct NAME name; // 'name' is a member of type 'struct NAME'\n    int age;\n    float salary;\n};\n\n// Structures can be passed as arguments to functions\nvoid print_name(struct NAME n) {\n    printf(\"%s %s\\n\", n.first, n.last);\n}\n\nint main(void) {\n    struct PERSON a;\n\n    // Accessing members of nested structures using chained dot operators\n    strcpy(a.name.first, \"John\");\n    strcpy(a.name.last, \"Smith\");\n    \n    print_name(a.name); // Passing a nested struct as a function argument\n    \n    return 0;\n}\n```\n\n## 6. Typedef and Structures (Example 16)\n\n`typedef` is often used with structures to create a new alias (type name) for the struct type, allowing you to declare variables without needing the `struct` keyword.\n\n*   **Syntax:** `typedef type new_name;`\n*   **Benefit:** Makes code cleaner and easier to read.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Defines a new type 'Person' which is an alias for 'struct { ... }'\ntypedef struct {\n    char name[30];\n    int age;\n    float salary;\n} Person; // 'Person' is the new type name, not a variable declaration\n\nint main(void) {\n    Person a, b; // Declaring variables using the new type name, 'struct' keyword is not needed\n    /* ... */\n    Person c;\n    \n    strcpy(a.name, \"Alice\");\n    a.age = 30;\n    a.salary = 60000.0f;\n    printf(\"%s is %d years old with salary %.2f\\n\", a.name, a.age, a.salary);\n    \n    return 0;\n}\n```\n\n## 7. Array of Structs (Example 17)\n\nYou can declare arrays where each element is a structure. This allows managing collections of related data.\n\n```c\n#include <stdio.h>\n\nstruct PERSON {\n    char name[30];\n    int age;\n    float salary;\n};\n\nint main() {\n    struct PERSON people[100]; // Declares an array of 100 PERSON structs\n\n    for(int x = 0; x < 100; x++) {\n        printf(\"Enter name for person %d: \", x + 1);\n        scanf(\"%s\", people[x].name);\n        printf(\"Enter age for person %d: \", x + 1);\n        scanf(\"%d\", &(people[x].age));\n        printf(\"Enter salary for person %d: \", x + 1);\n        scanf(\"%f\", &(people[x].salary));\n\n        if (people[x].age == 20)\n            printf(\"Hey you are 20!!\\n\");\n            \n        // For demonstration, break after 2 entries\n        if (x == 1) break; \n    }\n    \n    printf(\"\\nFirst two persons entered:\\n\");\n    printf(\"1. Name: %s, Age: %d, Salary: %.2f\\n\", people[0].name, people[0].age, people[0].salary);\n    printf(\"2. Name: %s, Age: %d, Salary: %.2f\\n\", people[1].name, people[1].age, people[1].salary);\n    \n    return 0;\n}\n```\n\n## 8. Sizeof and Structures (Memory Alignment) (Example 18)\n\n*   **Memory Placement:** In memory, members of a struct are conceptually placed in sequence.\n    `struct PERSON { char name[30]; int age; float salary; };`\n    Visual representation in memory: `[name (30 bytes)] [age (4 bytes)] [salary (4 bytes)]` (assuming typical sizes)\n*   **Memory Alignment/Padding:** Computers often require addresses of certain items (like integers) to be on specific memory multiples (e.g., an `int` might always start on an address divisible by 4).\n    *   To satisfy these alignment requirements, the compiler may insert unused bytes (called **padding**) between members.\n*   **Consequence:** Because of padding, the `sizeof` a struct might be larger than the simple sum of the sizes of its individual members.\n\n## 9. Recap and Key Takeaways\n\n*   **Syntax of `struct` types:**\n    *   `struct OPTIONAL_TAG { MEMBERS; } OPTIONAL_VARIABLES;`\n    *   `typedef struct { MEMBERS; } NEW_TYPE_NAME;`\n*   **Function Arguments and Return Values:** You can pass structs by value or by reference as arguments to functions, and you can also return them from functions.\n*   **Data Management:** Using structs makes it much more convenient to group and move related data, including arrays, as a single unit.\n*   **`sizeof` Caution:** The size of a struct (`sizeof(struct_variable)`) is not simply the sum of the sizes of its fields, as padding bytes may be added by the compiler for memory alignment.\n\n## 10. Practice Problem\n\nWrite a C program that does the following:\n\n1.  **Define `struct Coord`:** Create a structure type named `Coord` representing a coordinate in a 2D space (with `x` and `y` integer members).\n2.  **Implement `read_coords(int *capacity)` function:**\n    *   Dynamically allocate an array named `CoordArray` of `struct Coord` type.\n    *   The capacity of this array should be determined by user input (passed via `capacity` pointer).\n    *   Read coordinate inputs (x, y pairs) from the user and store them in the dynamically allocated `CoordArray`.\n    *   Return a pointer to the allocated `CoordArray`.\n3.  **Implement `Coord centroid(Coord *arr, int capacity)` function:**\n    *   Compute the centroid (average X and average Y) of all coordinates stored in the `arr`.\n    *   Return a `Coord` struct representing the centroid.\n4.  **`main` function:**\n    *   Call `read_coords` to get user coordinates.\n    *   Call `centroid` to calculate the centroid.\n    *   Output the computed centroid to the user.\n    *   Remember to free dynamically allocated memory.\n\n---",
    "restriction": "The size of each page should be of the format of one A4(8.27 × 11.69 in). There should be 2 pages exactly allowed. The content should be prioritized in the cheatsheet should be key concepts, examples. The following features of the crib sheet should make the sheet more comfortable to use, and should be prioritized: Compact, dense information in small text, Example problems with annotations. The overall layout style should be Hierarchical outline (headings and subpoints). The font size used in the cheatsheet should be in the Medium (11-12 pt) range to ensure readability and efficiency.",
    "error": null
}