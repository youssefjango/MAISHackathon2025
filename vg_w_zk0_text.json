{
    "text": "This document summarizes key concepts and examples related to C Structures, as presented in \"COMP 206 Lesson 16 Struct – Software Systems\" from McGill Slides by Vybihal & Bérubé-Vallières © 2023.\n\n---\n\n## C Structures (COMP 206 - Lesson 16)\n\n**Source:** McGill Slides – Vybihal & Bérubé-Vallières © 2023\n**Textbook Reference:** Section 3.0, Example 7\n**Topic:** Struct and Union Notes\n\n---\n\n### 1. Introduction to Structures\n\n*   **Definition:** Structures (`struct`) are a collection of items that may have different data types.\n*   **Elements:** Their elements are called **members**.\n*   **Access:** Unlike arrays, members are accessed by their **name**.\n\n---\n\n### 2. Declaring and Accessing Structures (Anonymous)\n\n**Initial Declaration (Global Variable)**\nStructures can be declared without a tag, making them \"anonymous.\"\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct {          // Anonymous struct\n    char name[30];\n    int age;\n    float salary;\n} a;              // Declares 'a' as a global variable of this struct type\n\nint main(void) {\n    a.age = 25;                       // Accessing members\n    strcpy(a.name, \"John\");           // Accessing members\n    printf(\"%s is %d years old\\n\", a.name, a.age);\n}\n```\n\n*   **Accessing Members:** Use the **dot operator (`.`)** (e.g., `a.age`).\n*   **Variable Declaration:** Follows the usual form: `type variable_name;`\n*   **Important:** Note the semicolon after the closing brace `}`.\n\n**Declaring Multiple Variables (Anonymous)**\nYou can declare multiple variables of the same anonymous struct type at once:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct {\n    char name[30];\n    int age;\n    float salary;\n} a, b; // Declares 'a' and 'b' as global variables\n\nint main(void) {\n    a.age = 25;\n    strcpy(a.name, \"John\");\n    b.age = 30;\n    strcpy(b.name, \"Bob\");\n    printf(\"%s is %d years old, %s is %d years old\\n\", a.name, a.age, b.name, b.age);\n}\n```\n\n**Problem with Anonymous Local Structures:**\nDeclaring the same anonymous structure multiple times locally is cumbersome and repetitive, as each declaration creates a *distinct* type.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    struct { // Anonymous struct type 1\n        char name[30];\n        int age;\n        float salary;\n    } a;\n    /* ... */\n    struct { // Anonymous struct type 2 (distinct from type 1)\n        char name[30];\n        int age;\n        float salary;\n    } b;\n}\n```\nThis is generally not recommended for repeated use.\n\n---\n\n### 3. Structure Tags (Named Structures)\n\n*   **Purpose:** Tags solve the problem of repetitive and distinct anonymous structure declarations, especially for local variables.\n*   **Declaration:** A tag gives a name to the structure definition.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct PERSON {       // 'PERSON' is the tag\n    char name[30];\n    int age;\n    float salary;\n};                    // Semicolon here, even if no variables declared\n\nint main(void) {\n    struct PERSON a;  // Declares 'a' of type 'struct PERSON'\n    /* ... */\n    struct PERSON b;  // Declares 'b' of type 'struct PERSON'\n}\n```\nThe tag replaces the need to redefine the members.\n\n**Global and Multiple Variable Declarations with Tags:**\nYou can still declare global variables or multiple variables at once when using a tag.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct PERSON {\n    char name[30];\n    int age;\n    float salary;\n} d; // 'd' is a global variable of type 'struct PERSON'\n\nint main(void) {\n    struct PERSON a, b; // 'a' and 'b' are local variables\n    /* ... */\n    struct PERSON c;    // 'c' is another local variable\n}\n```\n\n---\n\n### 4. General Syntax of `struct`\n\n```c\nstruct OPTIONAL_TAG {\n    MEMBERS;\n};\n```\n\n*   **`OPTIONAL_TAG`**: A user-defined name for the structure. If not present, the struct is anonymous.\n*   **`MEMBERS`**: A list of semicolon-separated variable declarations, e.g.:\n    ```c\n    TYPE1 VAR1;\n    TYPE2 VAR2;\n    // etc.\n    ```\n*   **Important Restriction:** You cannot initialize members from inside the `struct` definition (e.g., `int age = 0;` is not allowed here).\n\n---\n\n### 5. The Dot Operator (`.`)\n\nUsed to access fields (members) within a structure.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct PERSON {\n    char name[30];\n    int age;\n    float salary;\n};\n\nint main(void) {\n    struct PERSON a;\n    scanf(\"%s\", a.name);         // Accessing name member\n    scanf(\"%d\", &(a.age));       // Accessing age member (note '&' for int)\n    a.salary = 50.25;            // Assigning to salary member\n    printf(\"%s %d %f\", a.name, a.age, a.salary);\n}\n```\n\n---\n\n### 6. Struct Assignment\n\n*   **Behavior:** Unlike arrays, you can use the assignment operator (`=`) with structs.\n*   **Compatibility:** This works if the structs have compatible types (declared with the same tag, or if anonymous, declared at the same time).\n*   **Mechanism:** The assignment copies every member's value one by one (e.g., `b.x = a.x; b.y = a.y;`).\n*   **Arrays within Structs:** This even works with arrays that are members of structs!\n\n```c\n#include <stdio.h>\n\nstruct COORDINATE {\n    int x;\n    int y;\n};\n\nint main(void) {\n    struct COORDINATE a, b;\n    a.x = 5;\n    a.y = 7;\n    b = a; // Copies all members from 'a' to 'b'\n    printf(\"The coordinate of b is (%d, %d)\\n\", b.x, b.y);\n\n    // Example with array inside struct (demonstrating the \"surprisingly\" part)\n    struct { int arr[5]; } c, d;\n    c.arr[0] = 100;\n    d = c;\n    printf(\"d.arr[0] is %d\\n\", d.arr[0]); // Outputs 100\n}\n```\n\n---\n\n### 7. Nested Structures\n\n*   **Concept:** Structures can be used as members within other structures.\n*   **Access:** Use chained dot operators (e.g., `parent.child.member`).\n*   **Functions:** Structures can be passed as arguments to functions.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct NAME {\n    char first[30];\n    char last [30];\n};\n\nstruct PERSON {\n    struct NAME name; // Nested struct\n    int age;\n    float salary;\n};\n\nvoid print_name(struct NAME n) { // Struct passed as argument\n    printf(\"%s %s\\n\", n.first, n.last);\n}\n\nint main(void) {\n    struct PERSON a;\n    strcpy(a.name.first, \"John\"); // Chained dot operators\n    strcpy(a.name.last, \"Smith\"); // Chained dot operators\n    print_name(a.name);\n}\n```\n\n---\n\n### 8. `typedef` with Structures\n\n*   **Purpose:** `typedef` is often used with structs to create an alias (a new name) for the structure type, avoiding the need to use the `struct` keyword repeatedly.\n*   **Syntax:** `typedef type new_name;`\n\n```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[30];\n    int age;\n    float salary;\n} Person; // 'Person' is now an alias for this struct type\n\nint main(void) {\n    Person a, b; // No 'struct' keyword needed\n    /* ... */\n    Person c;\n}\n```\n*   `Person` in this context is the new type name, not a variable declaration.\n\n---\n\n### 9. Array of Structs\n\nYou can create arrays where each element is a structure.\n\n```c\n#include <stdio.h>\n\nstruct PERSON {\n    char name[30];\n    int age;\n    float salary;\n};\n\nint main() {\n    struct PERSON people[100]; // Array of 100 PERSON structs\n\n    for(int x = 0; x < 100; x++) {\n        printf(\"Enter name for person %d: \", x+1);\n        scanf(\"%s\", people[x].name); // Accessing member of struct at index x\n        printf(\"Enter age for person %d: \", x+1);\n        scanf(\"%d\", &(people[x].age));\n        printf(\"Enter salary for person %d: \", x+1);\n        scanf(\"%f\", &(people[x].salary));\n\n        if (people[x].age == 20) {\n            printf(\"Hey you are 20!!\\n\");\n        }\n    }\n}\n```\n\n---\n\n### 10. `sizeof` and Structs (Memory Alignment / Padding)\n\n*   **Memory Placement:** In memory, members of a struct are generally placed in sequence.\n*   **Padding:** However, compilers often require addresses of certain items to be on specific multiples (e.g., integers on multiples of 4). To achieve this, the compiler may insert **unused bytes (padding)** between elements.\n*   **Impact on `sizeof`:** Because of padding, the `sizeof` a struct might be larger than the simple sum of the sizes of its individual members.\n\n    ```\n    struct PERSON {\n        char name[30]; // 30 bytes\n        int age;       // 4 bytes (example)\n        float salary;  // 4 bytes (example)\n    };\n    // Expected sum: 30 + 4 + 4 = 38 bytes\n    // Actual sizeof(struct PERSON) might be, for example, 40 or 44 bytes due to padding.\n    ```\n    The layout in memory might look like: `name | padding | age | padding | salary | padding (at end of struct)`\n\n---\n\n### 11. Recap\n\n*   **Syntax:**\n    *   `struct OPTIONAL_TAG { MEMBERS; } OPTIONAL_VARIABLES;`\n    *   `typedef struct { MEMBERS; } NEW_TYPE_NAME;`\n*   **Function Interaction:** You can pass structs by value or by reference (using pointers) as arguments to functions, and you can also return them from functions.\n*   **Convenience:** Using structs makes it much more convenient to group and move related data, including arrays, as a single logical unit.\n*   **Size:** The size of a struct (`sizeof`) is not simply the sum of the sizes of its fields, as padding may be added for memory alignment purposes.\n\n---\n\n### 12. Practice Problem\n\n**Write a C program that does the following:**\n\n1.  Define a `struct Coord` type representing a coordinate in a 2D space (X and Y).\n2.  Implement a function `CoordArray* read_coords(int *capacity)` that:\n    *   Allocates a dynamic array named `CoordArray` of `struct Coord` type with a user-chosen capacity.\n    *   Reads coordinate inputs (X and Y) from the user and stores them in the dynamically allocated `CoordArray`.\n    *   Returns a pointer to the allocated `CoordArray`.\n3.  Implement a function `Coord centroid(Coord *arr, int capacity)` that computes the centroid (average X and Y) of all coordinates entered.\n4.  In the `main` function, output the computed centroid to the user.",
    "restriction": "The size of each page should be of the format of one A4(8.27 × 11.69 in). There should be 2 pages exactly allowed. The content should be prioritized in the cheatsheet should be examples. The following features of the crib sheet should make the sheet more comfortable to use, and should be prioritized: Compact, dense information in small text. The overall layout style should be Structured boxes or tables. The font size used in the cheatsheet should be in the Medium (11-12 pt) range to ensure readability and efficiency.",
    "error": null
}