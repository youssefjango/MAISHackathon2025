{
    "text": "Here's the information about C Structures, reformatted in an organized way:\n\n---\n\n# C Structures (struct) - COMP 206 Lesson 16\n\n**Course:** COMP 206 – Software Systems (Unix Bash C GNU Systems)\n**Lesson:** 16 - Struct\n**Instructors:** Vybihal & Bérubé-Vallières © 2023\n**Textbook Reference:** Section 3.0, Example 7\n\n---\n\n## 1. What are Structures?\n\n*   **Definition:** Structures (`struct`) are a collection of items that may have **different types**.\n*   **Members:** Its elements are called members.\n*   **Access:** Unlike arrays, members are accessed **by name**.\n\n---\n\n## 2. Declaring Structures\n\n### 2.1. Anonymous Structures (Global)\n\nAn anonymous structure is declared without a tag. Variables are created directly at the time of definition.\n\n**Example 1: Global Anonymous Struct (Single Variable)**\nHere's how a structure might be declared as a global variable, and its members accessed:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct {          // Anonymous struct\n    char name[30];  // members\n    int age;\n    float salary;\n} a;              // 'a' is a global variable of this anonymous struct type\n\nint main(void) {\n    a.age = 25;           // Accessing members\n    strcpy(a.name, \"John\");\n    printf(\"%s is %d years old\\n\", a.name, a.age);\n    return 0;\n}\n```\n*   **Note:** In reality, you would most likely use a structure tag, which is covered later.\n\n**Example 2: Global Anonymous Struct (Multiple Variables)**\nMultiple variables can be declared at the same time:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct {\n    char name[30];\n    int age;\n    float salary;\n} a, b; // 'a' and 'b' are global variables of this anonymous struct type\n\nint main(void) {\n    a.age = 25;\n    strcpy(a.name, \"John\");\n    b.age = 30;\n    strcpy(b.name, \"Bob\");\n    printf(\"%s is %d years old, %s is %d years old\\n\", a.name, a.age, b.name, b.age);\n    return 0;\n}\n```\n*   As usual, declarations can be of the form \"type var_name1, var_name2, ...\".\n\n### 2.2. Problem with Local Anonymous Structures\n\nDeclaring the same anonymous structure locally at different places is cumbersome because the compiler treats each definition as a *distinct* type, even if they have identical members.\n\n**Example 3: Cumbersome Local Anonymous Struct Declarations**\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    struct { // First local anonymous struct\n        char name[30];\n        int age;\n        float salary;\n    } a;\n    // ...\n    struct { // Second local anonymous struct (redundant definition)\n        char name[30];\n        int age;\n        float salary;\n    } b;\n    return 0;\n}\n```\n*   There is a better way to do this using **Structure Tags**.\n\n### 2.3. Structures with Tags\n\nStructure tags solve the problems from the previous slide by providing a reusable name for the structure's blueprint.\n\n**Example 4: Using a Structure Tag**\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Tag 'PERSON' defines the structure type\nstruct PERSON {\n    char name[30];\n    int age;\n    float salary;\n}; // Notice the semi-colon even though no variable declaration\n\nint main(void) {\n    struct PERSON a; // Declare a variable 'a' of type 'struct PERSON'\n    // ...\n    struct PERSON b; // Declare another variable 'b' of type 'struct PERSON'\n    return 0;\n}\n```\n*   The `Tag` (e.g., `PERSON`) replaces the need to redefine the members.\n\n**Example 5: Tags with Global and Multiple Variable Declarations**\nYou can still make global variables and declare multiple variables at the same time using tags.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct PERSON {\n    char name[30];\n    int age;\n    float salary;\n} d; // 'd' is a global variable of type 'struct PERSON'\n\nint main(void) {\n    struct PERSON a, b; // 'a' and 'b' are local variables\n    // ...\n    struct PERSON c;    // 'c' is another local variable\n    return 0;\n}\n```\n\n---\n\n## 3. Syntax of `struct`\n\nThe general syntax for defining a structure type is:\n\n```c\nstruct OPTIONAL_TAG {\n    MEMBERS;\n};\n```\nWhere:\n*   `OPTIONAL_TAG`: A user-defined name for the structure. If not present, the struct is anonymous.\n*   `MEMBERS`: A list of semi-colon separated variable declarations defining the structure's fields.\n    ```c\n    TYPE1 VAR1;\n    TYPE2 VAR2;\n    // etc.\n    ```\n*   **Important Note:** You **cannot initialize members** from inside the struct definition (e.g., `couldn't write int age = 0;`).\n\n---\n\n## 4. The Dot Operator\n\nTo access the fields (members) within a structure variable, we use the **dot operator (`.`)**.\n\n**Example:**\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct PERSON {\n    char name[30];\n    int age;\n    float salary;\n};\n\nint main(void) {\n    struct PERSON a;\n\n    printf(\"Enter name: \");\n    scanf(\"%s\", a.name);         // Access name member\n    printf(\"Enter age: \");\n    scanf(\"%d\", &(a.age));       // Access age member (note & for scanf)\n    a.salary = 50.25;            // Assign value to salary member\n\n    printf(\"Name: %s, Age: %d, Salary: %f\\n\", a.name, a.age, a.salary);\n    return 0;\n}\n```\n\n---\n\n## 5. Struct Assignment\n\nPerhaps surprisingly, we can use the **assignment operator (`=`) with structs** (unlike arrays) if they have compatible types.\n\n*   **Compatibility:** Structs are compatible if they are declared with the same tag, or if anonymous, declared at the same time.\n*   **Mechanism:** Assignment copies every member's value one by one (e.g., `b.x = a.x; b.y = a.y;`).\n\n**Example:**\n\n```c\n#include <stdio.h>\n\nstruct COORDINATE {\n    int x;\n    int y;\n};\n\nint main(void) {\n    struct COORDINATE a, b;\n    a.x = 5;\n    a.y = 7;\n    b = a; // Assignment copies a.x to b.x and a.y to b.y\n    printf(\"The coordinate of b is (%d, %d)\\n\", b.x, b.y);\n    return 0;\n}\n```\n*   **Even More Surprising:** This would work with arrays declared inside of structs!\n    ```c\n    struct { int arr[5]; } a, b;\n    a.arr[0] = 5;\n    b = a;\n    printf(\"%d\\n\", b.arr[0]); // Outputs 5\n    ```\n\n---\n\n## 6. Nested Structures\n\nStructures can be used as members within other structures.\n\n**Example:**\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct NAME {\n    char first[30];\n    char last [30];\n};\n\nstruct PERSON {\n    struct NAME name; // 'name' is a member of type 'struct NAME'\n    int age;\n    float salary;\n};\n\n// Function that takes a struct as an argument\nvoid print_name(struct NAME n) {\n    printf(\"%s %s\\n\", n.first, n.last);\n}\n\nint main(void) {\n    struct PERSON a;\n    strcpy(a.name.first, \"John\"); // Chained dot operators to access nested members\n    strcpy(a.name.last, \"Smith\");\n\n    print_name(a.name); // See how structs can be used as arguments\n    return 0;\n}\n```\n\n---\n\n## 7. `typedef` with Structures\n\nOften, people will use `typedef` in combination with structs to create an alias for the structure type, so the `struct` keyword doesn't have to be used repeatedly.\n\n*   **Reminder:** `typedef` is used like: `typedef existing_type new_name;`\n\n**Example:**\n\n```c\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {       // Define an anonymous struct\n    char name[30];\n    int age;\n    float salary;\n} Person;              // 'Person' is the new name for this struct type\n\nint main(void) {\n    Person a, b;       // 'Person' is now used directly as the type name\n    // ...\n    Person c;\n    return 0;\n}\n```\n*   Notice how the `struct` keyword is not used anymore when declaring variables of type `Person`.\n\n---\n\n## 8. Array of Structures\n\nYou can declare arrays where each element is a structure.\n\n**Example:**\n\n```c\n#include <stdio.h>\n\nstruct PERSON {\n    char name[30];\n    int age;\n    float salary;\n}; // Definition of the PERSON struct\n\nint main() {\n    struct PERSON people[100]; // An array of 100 PERSON structures\n\n    for(int x = 0; x < 2; x++) { // Example loop for 2 people\n        printf(\"Enter name for person %d: \", x+1);\n        scanf(\"%s\", people[x].name);\n        printf(\"Enter age for person %d: \", x+1);\n        scanf(\"%d\", &(people[x].age));\n        printf(\"Enter salary for person %d: \", x+1);\n        scanf(\"%f\", &(people[x].salary));\n\n        if (people[x].age == 20) {\n            printf(\"Hey you are 20!!\\n\");\n        }\n    }\n    // You could then iterate and print or process the array of structs\n    return 0;\n}\n```\n\n---\n\n## 9. `sizeof` and Structures (Memory Alignment)\n\n*   **Logical Layout:** In memory, members of a struct are placed in sequence (e.g., `name`, then `age`, then `salary`).\n\n    ```\n    struct PERSON {\n        char name[30];\n        int age;\n        float salary;\n    };\n    ```\n    Memory: `[name (30 bytes)] [age (4 bytes)] [salary (4 bytes)]` (Hypothetical ideal)\n\n*   **Actual Layout (Padding):** However, computers often require addresses of certain items to be on certain multiples (e.g., integers might always start on an address that is a multiple of 4).\n*   **Padding:** Because of this, the compiler can insert **unused bytes (padding)** between elements to ensure proper alignment.\n*   **Result:** As such, the `sizeof` a structure might be bigger than the simple sum of the sizes of its individual members, as it will include these unused bytes.\n\n---\n\n## 10. Recap\n\n*   **Syntax:**\n    *   Basic struct definition: `struct OPTIONAL_TAG { MEMBERS; } OPTIONAL_VARIABLES;`\n    *   Typedef for a struct: `typedef struct { MEMBERS; } NEW_TYPE_NAME;`\n*   **Functions:** You can pass structs by value or by reference as arguments to functions, and you can also return them.\n*   **Convenience:** Using structs makes it much more convenient to move related data (including arrays) around as a single unit.\n*   **Memory:** The size of a struct (`sizeof`) is not simply the sum of the sizes of its fields as **padding** may be added for memory alignment.\n\n---\n\n## 11. Practice Problem\n\nWrite a C program that does the following:\n\n1.  **Define a `struct Coord` type:** Representing a coordinate in a 2D space (X and Y integers).\n2.  **Implement `read_coords(int *capacity)`:**\n    *   Allocates a dynamic array named `CoordArray` of `struct Coord` type.\n    *   The capacity of the array should be of user choice.\n    *   Reads coordinate inputs (X and Y) from the user and stores them in the dynamically allocated `CoordArray`.\n3.  **Implement `Coord centroid(Coord *arr, int capacity)`:**\n    *   Computes the centroid (average X and average Y) of all coordinates entered.\n4.  **In the `main` function:**\n    *   Call `read_coords` to get the array of coordinates.\n    *   Call `centroid` to calculate the centroid.\n    *   Output the computed centroid to the user.\n    *   Remember to free dynamically allocated memory.\n\n---",
    "restriction": "The size of each page should be of the format of one A4(8.27 × 11.69 in). There should be 3 pages exactly allowed. The content should be prioritized in the cheatsheet should be key concepts, examples. The following features of the crib sheet should make the sheet more comfortable to use, and should be prioritized: Lots of white space and clear sections, Compact, dense information in small text. The overall layout style should be Free-form notes and sketches. The font size used in the cheatsheet should be in the Medium (11-12 pt) range to ensure readability and efficiency. The font size used in the cheatsheet should be in the Medium (11-12 pt) range to ensure readability and efficiency.",
    "error": null
}